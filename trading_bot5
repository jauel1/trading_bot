# TradingView Webhooks Trading Bot5 - Stocks
# Initial Release: 06-14-2023
# Version History
# 1.0 | 06-14-2023 | Initial release: Long and Short with close open position functionality
# 1.1 | 06-14-2023 | Add DynamoDB to store open positions
# 1.2 | 06-14-2023 | Add Amazon Event Handling to schedule closing of all open positions at the end of regular trading hours
# 1.3 | 06-15-2023 | Add locking mechanism to prevent race conditions between long sell and short sell
# 1.4 | 06-15-2023 | Add jitter retry logic to prevent concurrent locks from separate JSONs that come through at the same time
# 1.5 | 06-16-2023 | Add trailing stoploss functionality
# 1.6 | 06-16-2023 | Add delay before issuing trailing stop orders
# 1.7 | 06-21-2023 | Add function to cancel all open orders before and after market open and close 
# 1.8 | 06-22-2023 | Add stop loss to original market order 

import time
import random # (Version 1.4)
import alpaca_trade_api as tradeapi
from chalice import Chalice
import logging
import boto3
from botocore.exceptions import ClientError
from decimal import Decimal 

# Configure logging (Version 1.0)
logging.basicConfig(level=logging.INFO)

# Alpaca API credentials (Version 1.0)
API_KEY = 'PKKH8SPHB63GOD60PMDE'
SECRET_KEY = '4gKTvsa6rH3fjiolxkKih63FSDlzn0VjIJa4dpck'
BASE_URL = "https://paper-api.alpaca.markets"

# Initialize the Alpaca API (Version 1.0)
api = tradeapi.REST(API_KEY, SECRET_KEY, base_url=BASE_URL)

# Initialize AWS Lambda function (Version 1.0)
app = Chalice(app_name='alpaca-trading_bot5')

# Constants for trailing stop orders (Version 1.5)
TRAIL_PERCENT = ".25"  # .25% trail for the trailing stop orders
TRAIL_STOP_ISSUE_DELAY = 5

# Constants to recheck if a trailing stop has been placed (Version 1.5)
TRAILING_STOP_CHECK_DELAY = 1  # Delay in seconds to check for trailing stop orders
MAX_TRAILING_STOP_CHECK_RETRIES = 15  # Maximum number of times to check for trailing stop orders

# Constants for order cancellation retry (Version 1.5)
CANCEL_WAIT_TIME_SEC = 2  # Time to wait before retrying the order cancellation
MAX_CANCEL_ORDER_RETRIES = 15  # Maximum number of order cancellation retries

# Constants for stoploss orders (Version 1.8)
BUY_STOP_LOSS_PERCENT = 0.9975
SELL_STOP_LOSS_PERCENT = 1.0025

# Initialize DynamoDB resource and specify table name (Version 1.3)
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('TradingBot5OpenPositions')

# Get current open position for ticker from DynamoDB (Version 1.3)
def get_position(ticker):
    try:
        response = table.get_item(Key={'ticker': ticker})
        if 'Item' in response:
            return response['Item']
        else:
            return None
    except ClientError as e:
        logging.error(f'Failed to get position for {ticker} from DynamoDB: {e}')
        raise

# Function to close position for a given ticker (Version 1.0)
def close_position(ticker):
    max_retries = 15
    retry_count = 0
    order_id = None

    # Cancel open trailing stop orders (Version 1.5)
    cancel_open_trailing_stop_orders_for_ticker(ticker)

    # Check if the position exists before attempting to close it (Version 1.0)
    positions = api.list_positions()
    if not any(p.symbol == ticker for p in positions):
        logging.warning(f"No position found for {ticker}. Nothing to close.")
        return

    while retry_count < max_retries:
        try:
            if order_id is None:
                order = api.close_position(ticker)
                order_id = order.id
                logging.info(f"Order submitted to close position for {ticker}. Order ID: {order_id}")

            order_status = api.get_order(order_id).status
            logging.info(f"Order status for {ticker}: {order_status}")

            if order_status == 'filled':
                logging.info(f"Successfully closed position for {ticker}.")
                return
            elif order_status in ['rejected', 'canceled']:
                logging.warning(f"Order to close position for {ticker} was {order_status}.")
                return
        except Exception as e:
            logging.error(f"An exception occurred while closing position for {ticker}: {e}")

        retry_count += 1
        time.sleep(1)
    
    logging.warning(f"Max retries reached while trying to close position for {ticker}. Position may not be fully closed.")
            
# Function to close all positions with a single call to Alpaca API (Version 1.0)
def close_all_positions():
    logging.info("Closing all positions...")

    # Cancel all open trailing stop orders for each position
    positions = api.list_positions()
    for position in positions:
        ticker = position.symbol
        cancel_open_trailing_stop_orders_for_ticker(ticker)

    try:
        # Close all positions (Version 1.0)
        api.close_all_positions()
        logging.info("Successfully requested to close all positions.")
    except Exception as e:
        # Log any exceptions for troubleshooting (Version 1.0)
        logging.error(f"An exception occurred while closing all positions: {e}")

# Function to add a trailing stop order after a new position is filled (Version 1.5)
def place_trailing_stop_order(ticker, side, qty):
    try:
        logging.info(f'Placing trailing stop order for {ticker}...')
        api.submit_order(
            symbol=ticker,
            qty=qty,
            side=side,
            type='trailing_stop',
            trail_percent=TRAIL_PERCENT,
            time_in_force='gtc',
        )
        logging.info(f'Trailing stop order placed for {ticker}')
    except Exception as e:
        logging.error(f"Error placing trailing stop order for {ticker}: {e}")

# Function to check if a ticker with an open position has a trailing stop associated with it (Version 1.5)
def has_trailing_stop_order(ticker):
    """
    Check if there is an open trailing stop order for the given ticker.
    """
    try:
        open_orders = api.list_orders(status='open')
        for order in open_orders:
            if order.symbol == ticker and order.type == 'trailing_stop':
                return True
        return False
    except Exception as e:
        logging.error(f"Error checking for open trailing stop orders for {ticker}: {e}")
        return False
    
# Cancel all open trailing stop orders for the given ticker (Version 1.5)
def cancel_open_trailing_stop_orders_for_ticker(ticker):
    """
    Cancel all open trailing stop orders for the given ticker.
    """
    try:
        open_orders = api.list_orders(status='open')
        for order in open_orders:
            if order.symbol == ticker and order.type == 'trailing_stop':
                api.cancel_order(order.id)
                logging.info(f"Attempted to cancel trailing stop order for {ticker}")

                # Check if the order is cancelled
                retries = 0
                while retries < MAX_CANCEL_ORDER_RETRIES:
                    time.sleep(CANCEL_WAIT_TIME_SEC)
                    order_check = api.get_order(order.id)
                    if order_check.status == 'cancelled':
                        logging.info(f"Trailing stop order for {ticker} cancelled successfully.")
                        break
                    else:
                        retries += 1
                        logging.info(f"Trailing stop order not cancelled. Retrying.")
                if retries >= MAX_CANCEL_ORDER_RETRIES:
                    logging.error(f"Failed to cancel trailing stop order for {ticker} after {MAX_CANCEL_ORDER_RETRIES} attempts.")
    except Exception as e:
        logging.error(f"Error cancelling open trailing stop orders for {ticker}: {e}")

# Scheduled function to run 5 minutes before market close (Version 1.2)
@app.schedule('cron(55 19 ? * MON-FRI *)')
def scheduled_close_5mins_before_close(event):
    close_all_positions()

# Scheduled function to run 3 minutes before market close (Version 1.2)
@app.schedule('cron(57 19 ? * MON-FRI *)')
def scheduled_close_3mins_before_close(event):
    close_all_positions()

# Scheduled function to run 1 minute before market close (Version 1.2)
@app.schedule('cron(59 19 ? * MON-FRI *)')
def scheduled_close_1min_before_close(event):
    close_all_positions()

# Function to cancel all open orders with retries every 5 seconds (up to 15 retries)
def cancel_all_open_orders_with_retries():
    max_retries = 15
    retry_count = 0
    while retry_count < max_retries:
        try:
            open_orders = api.list_orders(status='open')
            if not open_orders:
                logging.info("No open orders left. Exiting cancellation loop.")
                return
            
            for order in open_orders:
                api.cancel_order(order.id)
                logging.info(f"Attempted to cancel order for {order.symbol}")

        except Exception as e:
            logging.error(f"An exception occurred while cancelling open orders: {e}")

        retry_count += 1
        time.sleep(5)

    logging.warning(f"Max retries reached while trying to cancel open orders. Some orders may still be open.")

# Scheduled function to cancel all open orders 6 minutes before market close (runs every 5 seconds, max 15 retries)
@app.schedule('cron(54 19 ? * MON-FRI *)')
def cancel_orders_before_market_close(event):
    cancel_all_open_orders_with_retries()

# Scheduled function to cancel all open orders 1 hr 5 minutes after market close in CDT and 5 minutes before in CST (runs every 5 seconds, max 15 retries)
@app.schedule('cron(5 21 ? * MON-FRI *)')
def cancel_orders_after_market_close(event):
    cancel_all_open_orders_with_retries()

# Scheduled function to cancel all open orders 1 hr 5 minutes before market open in CDT and 5 minutes before in CST (runs every 5 seconds, max 15 retries)
@app.schedule('cron(25 12 ? * MON-FRI *)')
def cancel_orders_before_market_open(event):
    cancel_all_open_orders_with_retries()

# Function to acquire a lock on the DynamoDB (Version 1.3)
def acquire_lock(ticker, max_retries=5):
    retry_count = 0
    current_time = int(time.time())
    lock_expiration = 60  # 60 seconds, lock expiration time in seconds (Version 1.3)

    while retry_count < max_retries:
        try:
            # Try to acquire lock (Version 1.3)
            table.update_item(
                Key={'ticker': ticker},
                UpdateExpression='SET #lock = :lockval, lock_timestamp = :timestamp',
                ConditionExpression='attribute_not_exists(ticker) OR attribute_not_exists(#lock) OR #lock = :false OR (lock_timestamp < :expired_time)',
                ExpressionAttributeNames={'#lock': 'lock'},
                ExpressionAttributeValues={
                    ':lockval': True,
                    ':false': False,
                    ':timestamp': current_time,
                    ':expired_time': current_time - lock_expiration
                }
            )
            # Lock acquired (Version 1.3)
            return True
        except ClientError as e:
            # Lock not acquired, log the error details (Version 1.3)
            logging.error(f"Failed to acquire lock on attempt {retry_count + 1}. Error: {e.response['Error']['Message']}")

        retry_count += 1
        sleep_time = 0.5 + random.random()  # Sleep for 0.5 to 1.5 seconds (Version 1.4)
        logging.info(f"Sleeping for {sleep_time} seconds before retrying.")
        time.sleep(sleep_time)
    
    # Failed to acquire lock after maximum retries (Version 1.3)
    logging.error(f"Failed to acquire lock for ticker {ticker} after maximum retries.")
    return False

# Function to release a lock on the DynamoDB (Version 1.3)
def release_lock(ticker):
    table.update_item(
        Key={'ticker': ticker},
        UpdateExpression='SET #lock = :lockval',
        ExpressionAttributeNames={'#lock': 'lock'},
        ExpressionAttributeValues={':lockval': False}
    )

# Function to place a market order for new positions (Version 1.0)
def place_order(data):
    lock_acquired = False
    try:
        ticker = data["ticker"]
        order_type = data["order_type"]
        order_qty = int(data["order_qty"])
        prev_order_qty = int(data.get("prev_order_qty", 0))

        # Add a 1-second delay for long sell if the order type is sell and prev_order_qty is greater than 0
        if order_type == 'sell' and prev_order_qty > 0:
            logging.info(f"Delaying execution of long sell order for {ticker} by 1 second.")
            time.sleep(1)

        # Try to acquire lock
        lock_acquired = acquire_lock(ticker)
        if not lock_acquired:
            logging.error(f"Failed to acquire lock for ticker {ticker} after maximum retries. Cancelling operation.")
            return
        
        # Retrieve the existing position for the ticker if exists
        existing_position = get_position(ticker)
        if existing_position:
            existing_position_type = existing_position.get('position')
            new_position_type = 'long' if order_type == 'buy' and order_qty > 0 else 'short'
            
            # Close the existing position if it is of a different type
            if existing_position_type != new_position_type:
                logging.info(f'Closing existing {existing_position_type} position for {ticker}...')
                close_position(ticker)
            else:
                logging.info(f'Existing position for {ticker} is of the same type ({existing_position_type}). Not closing it.')
        
        # Check if the order quantity is greater than 0
        if order_qty > 0:

           # Submit the new order to Alpaca with Stoploss (Version 1.8)
            logging.info(f'Placing a {order_type} order for {ticker}...')
            order = api.submit_order(
                symbol=ticker,
                qty=order_qty,
                side=order_type,
                type='market',
                time_in_force='gtc',
                order_class='oto', # (Version 1.8)
                stop_loss={'stop_price': round(filled_avg_price * Decimal(stop_loss_percent), 2)} , # (Version 1.8)
                extended_hour=False
            )

            # Retrieve the filled average price for the order (Version 1.8)
            filled_avg_price = float(api.get_order(order.id).filled_avg_price)

            # Determine the stop loss percentage based on the order type (Version 1.8)
            if order_type == 'buy':
                stop_loss_percent = BUY_STOP_LOSS_PERCENT
            elif order_type == 'sell':
                stop_loss_percent = SELL_STOP_LOSS_PERCENT
            else:
                logging.error(f"Invalid order type: {order_type}")
                return

            # Calculate the stop loss price based on the filled average price and the stop loss percentage (Version 1.8)
            stop_loss_price = round(filled_avg_price * Decimal(stop_loss_percent), 2)

            # Update the stop loss order with the calculated stop loss price (Version 1.8)
            order.stop_loss = {'stop_price': stop_loss_price}
            api.replace_order(order.id, order)

            # Wait for the order to be filled
            max_wait_time = 30  # Max seconds to wait for the order to be filled
            wait_time = 0
            while True:
                order_status = api.get_order(order.id).status
                if order_status == "filled":
                    break
                if wait_time > max_wait_time:
                    logging.error(f"Order for {ticker} was not filled in time.")
                    return
                
                time.sleep(1)
                wait_time += 1

            # Implement a 5-second delay after the order is filled before placing the trailing stop order (Version 1.6)
            logging.info(f"Waiting 5 seconds before placing trailing stop order for {ticker}...")
            time.sleep(5)                

            # Place a trailing stop order (Version 1.5)
            trail_side = 'sell' if order_type == 'buy' else 'buy'
            place_trailing_stop_order(ticker, trail_side, order_qty)

            # Update the position in DynamoDB
            position_type = 'long' if order_type == 'buy' else 'short'
            table.put_item(Item={'ticker': ticker, 'position': position_type})
        
        # Release lock
        release_lock(ticker)
        lock_acquired = False

    except Exception as e:
        logging.error(f"Error placing order: {e}")
    finally:
        # Ensure that the lock is released if it has been acquired
        if lock_acquired:
            release_lock(ticker)

# Define main function to trade stocks (Version 1.0)
@app.route('/trade_stocks_bot5', methods=['POST'])
def trade_stocks_bot5():
    request = app.current_request
    webhook_message = request.json_body

    ticker = webhook_message['ticker']
    order_type = webhook_message['order_type']
    order_qty = webhook_message['order_qty']

    logging.info(f'Received order: {order_type} {order_qty} shares of {ticker}')

    try:
        # Submit the order (Version 1.0)
        data = {
            "ticker": ticker,
            "order_qty": order_qty,
            "order_type": order_type,
        }
        place_order(data)

    except Exception as e:
        logging.error(f"Error processing order: {e}")

    return {'status': 'ok'}

if __name__ == "__main__":
    app.run()
